use std::collections::BTreeMap;

use crate::rounds::keygen as keygen_protocol;
use crate::FrostContext;
use api::services::events::JobCalled;
use blueprint_sdk::contexts::keystore::KeystoreContext;
use blueprint_sdk::contexts::tangle::TangleClientContext;
use blueprint_sdk::crypto::hashing::keccak_256;
use blueprint_sdk::crypto::tangle_pair_signer::sp_core::ecdsa;
use blueprint_sdk::keystore::backends::Backend;
use blueprint_sdk::keystore::crypto::sp_core::SpEcdsa;
use blueprint_sdk::networking::InstanceMsgPublicKey;
use blueprint_sdk::tangle_subxt::subxt::ext::futures::TryFutureExt;
use blueprint_sdk::{self as sdk, logging};
use frost_core::keys::{KeyPackage, PublicKeyPackage};
use frost_core::{Ciphersuite, VerifyingKey};
use sdk::event_listeners::tangle::{
    events::TangleEventListener, services::services_post_processor,
    services::services_pre_processor,
};
use sdk::networking::round_based_compat::RoundBasedNetworkAdapter;
use sdk::tangle_subxt::subxt_core::utils::AccountId32;
use sdk::tangle_subxt::tangle_testnet_runtime::api;

#[derive(Debug, thiserror::Error)]
pub enum Error {
    #[error("Unknown ciphersuite: {0}")]
    UnknwonCiphersuite(String),
    #[error("Self not in operators")]
    SelfNotInOperators,
    #[error(transparent)]
    Subxt(#[from] sdk::tangle_subxt::subxt::Error),
    #[error(transparent)]
    Sdk(#[from] sdk::error::Error),
    #[error(transparent)]
    Config(#[from] Box<sdk::config::Error>),
    #[error("Frost error: {0}")]
    Frost(Box<dyn std::error::Error>),
    #[error("Protocol error: {0}")]
    Protocol(Box<dyn std::error::Error>),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    ToUnsigned16(#[from] std::num::TryFromIntError),
    #[error(transparent)]
    Io(#[from] std::io::Error),
    #[error(transparent)]
    Other(color_eyre::eyre::Error),
}

impl<C: Ciphersuite> From<frost_core::Error<C>> for Error {
    fn from(e: frost_core::Error<C>) -> Self {
        Error::Frost(Box::new(e))
    }
}

impl<C: Ciphersuite> From<keygen_protocol::Error<C>> for Error {
    fn from(e: keygen_protocol::Error<C>) -> Self {
        Error::Protocol(Box::new(e))
    }
}

/// Run Keygen Protocol between the operators and return the public key.
///
/// # Parameters
/// - `ciphersuite`: The ciphersuite to use in the keygen protocol
/// - `threshold`: The threshold of the keygen protocol.
/// # Returns
/// The public key generated by the keygen protocol.
///
/// # Errors
/// - `UnknwonCiphersuite`: The ciphersuite is not supported.
/// - `SelfNotInOperators`: The current operator is not in the operators.
///
/// # Note
/// - `ciphersuite`: The `ID` of the ciphersuite; oneof [`FROST-ED25519-SHA512-v1`, `FROST-secp256k1-SHA256-v1`].
/// - `threshold`: The threshold of the keygen protocol should be less than the number of operators.
#[sdk::job(
    id = 0,
    params(ciphersuite, threshold),
    result(_),
    event_listener(
        listener = TangleEventListener::<FrostContext, JobCalled>,
        pre_processor = services_pre_processor,
        post_processor = services_post_processor,
    )
)]
#[tracing::instrument(target = "gadget", skip(context), err)]
pub async fn keygen(
    ciphersuite: String,
    threshold: u16,
    context: FrostContext,
) -> Result<Vec<u8>, Error> {
    logging::info!("Running keygen job");
    let tangle_client = context
        .tangle_client()
        .map_err(|e| Error::Sdk(e.into()))
        .await?;

    let (i, operators) = tangle_client
        .get_party_index_and_operators()
        .map_err(|e| Error::Sdk(e.into()))
        .await?;

    let my_ecdsa = context
        .keystore()
        .first_local::<SpEcdsa>()
        .map_err(|e| Error::Other(e.into()))?;
    let current_call_id = context.current_call_id().map_err(Error::Other)?;

    let rng = rand::rngs::OsRng;
    let kv = context.store.clone();
    let key = match ciphersuite.as_str() {
        frost_ed25519::Ed25519Sha512::ID => keygen_internal::<frost_ed25519::Ed25519Sha512, _>(
            rng,
            kv,
            my_ecdsa.0,
            operators,
            i.try_into()?,
            threshold,
            current_call_id,
            &context,
        )
        .await?
        .serialize()?,
        frost_secp256k1::Secp256K1Sha256::ID => {
            keygen_internal::<frost_secp256k1::Secp256K1Sha256, _>(
                rng,
                kv,
                my_ecdsa.0,
                operators,
                i.try_into()?,
                threshold,
                current_call_id,
                &context,
            )
            .await?
            .serialize()?
        }
        _ => return Err(Error::UnknwonCiphersuite(ciphersuite)),
    };

    Ok(key)
}

/// A KeygenEntry to store the keygen result.
#[derive(Clone, Debug, serde::Serialize, serde::Deserialize)]
#[serde(bound = "C: Ciphersuite")]
pub struct KeygenEntry<C: Ciphersuite> {
    pub key_pkg: KeyPackage<C>,
    pub pub_key_pkg: PublicKeyPackage<C>,
}

/// A generic keygen protocol over any ciphersuite.
#[tracing::instrument(skip(rng, kv, context), fields(ciphersuite = %C::ID,  i, n = %participants.len()))]
#[allow(clippy::too_many_arguments)]
async fn keygen_internal<C, R>(
    mut rng: R,
    kv: crate::kv::SharedDynKVStore<String, Vec<u8>>,
    me: ecdsa::Public,
    participants: BTreeMap<AccountId32, ecdsa::Public>,
    i: u16,
    t: u16,
    call_id: u64,
    context: &FrostContext,
) -> Result<VerifyingKey<C>, Error>
where
    C: Ciphersuite + Sync + Send + Unpin,
    <<C as Ciphersuite>::Group as frost_core::Group>::Element: Sync + Send + Unpin,
    <<<C as Ciphersuite>::Group as frost_core::Group>::Field as frost_core::Field>::Scalar:
        Send + Sync + Unpin,
    R: rand::RngCore + rand::CryptoRng,
{
    let n = participants.len();

    let n = u16::try_from(n)?;

    logging::info!(%i, %n, "Keygen Start");

    let parties: BTreeMap<u16, _> = participants
        .into_iter()
        .enumerate()
        .map(|(j, (_, ecdsa))| (j as u16, ecdsa))
        .collect();

    let keygen_task_hash = keccak_256(&call_id.to_be_bytes());

    let delivery = RoundBasedNetworkAdapter::new(
        context.network_service_handle.clone(),
        i as _,
        parties
            .iter()
            .map(|(j, ecdsa)| (*j, InstanceMsgPublicKey(*ecdsa)))
            .collect(),
        hex::encode(keygen_task_hash),
    );
    let party = round_based::MpcParty::connected(delivery);
    let (key_package, public_key_package) =
        keygen_protocol::run::<R, C, _>(&mut rng, t, n, i, party, None).await?;
    let verifying_key = *public_key_package.verifying_key();
    let pubkey = hex::encode(verifying_key.serialize()?);
    logging::debug!(%pubkey, "Keygen Done");
    let entry = serde_json::json!({
        "ciphersuite": C::ID,
        "entry": KeygenEntry {
            key_pkg: key_package,
            pub_key_pkg: public_key_package,
        },
    });
    // Save the keygen entry.
    kv.set(pubkey, serde_json::to_vec(&entry)?)?;
    Ok(verifying_key)
}
