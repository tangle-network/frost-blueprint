use api::services::events::JobCalled;
use frost_core::keys::{KeyPackage, PublicKeyPackage};
use frost_core::{Ciphersuite, VerifyingKey};
use gadget_sdk::network::Network;
use gadget_sdk::{self as sdk, random};
use sdk::ctx::{GossipNetworkContext, ServicesContext, TangleClientContext};
use sdk::event_listener::tangle::{
    jobs::{services_post_processor, services_pre_processor},
    TangleEventListener,
};
use sdk::tangle_subxt::subxt::tx::Signer;
use sdk::tangle_subxt::tangle_testnet_runtime::api;

use crate::rounds::{delivery, keygen as keygen_protocol};
use crate::ServiceContext;

#[derive(Debug, thiserror::Error)]
pub enum Error {
    #[error("Unknown ciphersuite: {0}")]
    UnknwonCiphersuite(String),
    #[error("Self not in operators")]
    SelfNotInOperators,

    #[error(transparent)]
    Subxt(#[from] sdk::tangle_subxt::subxt::Error),
    #[error(transparent)]
    Sdk(#[from] sdk::error::Error),
    #[error(transparent)]
    Config(#[from] sdk::config::Error),
    #[error("Frost error: {0}")]
    Frost(Box<dyn std::error::Error>),
    #[error("Protocol error: {0}")]
    Protocol(Box<dyn std::error::Error>),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    ToUnsigned16(#[from] std::num::TryFromIntError),
    #[error(transparent)]
    Io(#[from] std::io::Error),
}

impl<C: Ciphersuite> From<frost_core::Error<C>> for Error {
    fn from(e: frost_core::Error<C>) -> Self {
        Error::Frost(Box::new(e))
    }
}

impl<C: Ciphersuite> From<keygen_protocol::Error<C>> for Error {
    fn from(e: keygen_protocol::Error<C>) -> Self {
        Error::Protocol(Box::new(e))
    }
}

/// Run Keygen Protocol between the operators and return the public key.
///
/// # Parameters
/// - `ciphersuite`: The ciphersuite to use in the keygen protocol
/// - `threshold`: The threshold of the keygen protocol.
/// # Returns
/// The public key generated by the keygen protocol.
///
/// # Errors
/// - `UnknwonCiphersuite`: The ciphersuite is not supported.
/// - `SelfNotInOperators`: The current operator is not in the operators.
///
/// # Note
/// - `ciphersuite`: The `ID` of the ciphersuite; oneof [`FROST-ED25519-SHA512-v1`, `FROST-secp256k1-SHA256-v1`].
/// - `threshold`: The threshold of the keygen protocol should be less than the number of operators.
#[sdk::job(
    id = 0,
    params(ciphersuite, threshold),
    result(_),
    event_listener(
        listener = TangleEventListener::<ServiceContext, JobCalled>,
        pre_processor = services_pre_processor,
        post_processor = services_post_processor,
    )
)]
#[tracing::instrument(skip(context), parent = context.config.span.clone())]
pub async fn keygen(
    ciphersuite: String,
    threshold: u16,
    context: ServiceContext,
) -> Result<Vec<u8>, Error> {
    let client = context.tangle_client().await?;
    let operators_with_restake = context.current_service_operators(&client).await?;
    let my_key = context.config.first_sr25519_signer()?;
    let n = operators_with_restake.len();
    let i = operators_with_restake
        .iter()
        .map(|(op, _)| op)
        .position(|op| op == &my_key.account_id())
        .ok_or(Error::SelfNotInOperators)?;

    sdk::info!(%n, %i, t = %threshold, %ciphersuite, "Keygen");
    let net = context.gossip_network().clone();
    let rng = random::rand::rngs::OsRng;
    let kv = context.store.clone();
    let key = match ciphersuite.as_str() {
        frost_ed25519::Ed25519Sha512::ID => keygen_internal::<frost_ed25519::Ed25519Sha512, _, _>(
            rng,
            net,
            kv,
            threshold,
            u16::try_from(n)?,
            u16::try_from(i)?,
        )
        .await?
        .serialize()?,
        frost_secp256k1::Secp256K1Sha256::ID => {
            keygen_internal::<frost_secp256k1::Secp256K1Sha256, _, _>(
                rng,
                net,
                kv,
                threshold,
                u16::try_from(n)?,
                u16::try_from(i)?,
            )
            .await?
            .serialize()?
        }
        _ => return Err(Error::UnknwonCiphersuite(ciphersuite)),
    };

    Ok(key)
}

/// A KeygenEntry to store the keygen result.
#[derive(Clone, Debug, serde::Serialize, serde::Deserialize)]
#[serde(bound = "C: Ciphersuite")]
pub struct KeygenEntry<C: Ciphersuite> {
    pub keypkg: KeyPackage<C>,
    pub pubkeypkg: PublicKeyPackage<C>,
}

/// A genaric keygen protocol over any ciphersuite.
#[tracing::instrument(skip(rng, net, kv))]
async fn keygen_internal<C, R, N>(
    mut rng: R,
    net: N,
    kv: crate::kv::SharedDynKVStore<String, Vec<u8>>,
    t: u16,
    n: u16,
    i: u16,
) -> Result<VerifyingKey<C>, Error>
where
    C: Ciphersuite + Send + Unpin,
    <<C as Ciphersuite>::Group as frost_core::Group>::Element: Send + Unpin,
    <<<C as Ciphersuite>::Group as frost_core::Group>::Field as frost_core::Field>::Scalar:
        Send + Unpin,
    R: random::RngCore + random::CryptoRng,
    N: Network + Unpin,
{
    let delivery = delivery::NetworkDeliveryWrapper::new(net, i);
    let party = round_based::MpcParty::connected(delivery);
    let (key_package, public_key_package) =
        keygen_protocol::run::<R, C, _>(&mut rng, t, n, i, party, None).await?;
    let verifying_key = public_key_package.verifying_key().clone();
    let pubkey = hex::encode(verifying_key.serialize()?);
    sdk::debug!(
        %i,
        %pubkey,
        "Keygen Done"
    );
    let entry = serde_json::json!({
        "ciphersuite": C::ID,
        "entry": KeygenEntry {
            keypkg: key_package,
            pubkeypkg: public_key_package,
        },
    });
    // Save the keygen entry.
    kv.set(pubkey, serde_json::to_vec(&entry)?)?;
    Ok(verifying_key)
}

#[cfg(test)]
mod tests {
    use api::runtime_types::bounded_collections::bounded_vec::BoundedVec;
    use api::runtime_types::tangle_primitives::services::field::BoundedString;
    use api::runtime_types::tangle_primitives::services::field::Field;
    use api::services::calls::types::call::Args;
    use blueprint_test_utils::test_ext::*;
    use blueprint_test_utils::*;
    use cargo_tangle::deploy::Opts;
    use gadget_sdk::error;
    use gadget_sdk::info;

    use super::*;

    pub fn setup_testing_log() {
        use tracing_subscriber::util::SubscriberInitExt;
        let _ = tracing_subscriber::fmt::SubscriberBuilder::default()
            .without_time()
            .with_span_events(tracing_subscriber::fmt::format::FmtSpan::NONE)
            .with_env_filter(tracing_subscriber::EnvFilter::from_default_env())
            .with_test_writer()
            .finish()
            .try_init();
    }

    #[tokio::test(flavor = "multi_thread")]
    #[allow(clippy::needless_return)]
    async fn keygen() {
        setup_testing_log();
        let tangle = crate::test_utils::run_tangle().unwrap();
        let base_path = std::env::current_dir().expect("Failed to get current directory");
        let base_path = base_path
            .canonicalize()
            .expect("File could not be normalized");

        let manifest_path = base_path.join("Cargo.toml");

        let opts = Opts {
            pkg_name: option_env!("CARGO_BIN_NAME").map(ToOwned::to_owned),
            http_rpc_url: format!("http://127.0.0.1:{}", tangle.ws_port()),
            ws_rpc_url: format!("ws://127.0.0.1:{}", tangle.ws_port()),
            manifest_path,
            signer: None,
            signer_evm: None,
        };

        const N: usize = 3;
        const T: usize = N / 2 + 1;
        const CIPHERSUITE: &str = frost_ed25519::Ed25519Sha512::ID;

        new_test_ext_blueprint_manager::<N, 1, _, _, _>("", opts, run_test_blueprint_manager)
            .await
            .execute_with_async(move |client, handles, svcs| async move {
                // At this point, blueprint has been deployed, every node has registered
                // as an operator for the relevant services, and, all gadgets are running

                let keypair = handles[0].sr25519_id().clone();

                let service = svcs.services.last().unwrap();

                let service_id = service.id;
                let call_id = get_next_call_id(client)
                    .await
                    .expect("Failed to get next job id")
                    .saturating_sub(1);

                info!("Submitting job with params service ID: {service_id}, call ID: {call_id}");

                // Pass the arguments
                let ciphersuite = Field::String(BoundedString(BoundedVec(
                    CIPHERSUITE.to_string().into_bytes(),
                )));
                let threshold = Field::Uint16(T as u16);
                let job_args = Args::from([ciphersuite, threshold]);

                // Wait till we reach block 20 to ensure all nodes have the same view
                let mut blocks = client.blocks().subscribe_finalized().await.unwrap();
                while let Some(Ok(block)) = blocks.next().await {
                    if block.number() >= 20 {
                        break;
                    }
                }
                // Next step: submit a job under that service/job id
                if let Err(err) =
                    submit_job(client, &keypair, service_id, KEYGEN_JOB_ID, job_args).await
                {
                    error!("Failed to submit job: {err}");
                    panic!("Failed to submit job: {err}");
                }

                // Step 2: wait for the job to complete
                let job_results = wait_for_completion_of_tangle_job(client, service_id, call_id, N)
                    .await
                    .expect("Failed to wait for job completion");

                // Step 3: Get the job results, compare to expected value(s)
                assert_eq!(job_results.service_id, service_id);
                assert_eq!(job_results.call_id, call_id);
                assert!(matches!(job_results.result[0], Field::Bytes(_)));
            })
            .await
    }
}
